"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const inquirer = require("inquirer");
const fs = require("mz/fs");
const path = require("path");
const yargs = require("yargs");
const adapter_1 = require("./adapter");
const git_1 = require("./git");
const git_2 = require("./git");
const index_1 = require("./index");
const migration_1 = require("./migration");
const pkg = require('../package.json');
require('update-notifier')({ pkg }).notify();
class MigrationDirNotSpecifiedError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'MigrationDirNotSpecifiedError';
    }
}
exports.MigrationDirNotSpecifiedError = MigrationDirNotSpecifiedError;
const dbOption = {
    description: 'The connection URL for the database',
    nargs: 1,
    require: true,
};
yargs
    .env('MERKEL')
    .option('config', {
    alias: 'c',
    global: true,
    config: true,
    default: '.merkelrc.json',
})
    .demand(1)
    .usage('\nUsage: merkel [options] <command>')
    .wrap(90)
    .option('migration-dir', {
    description: 'The directory for migration files',
    nargs: 1,
    global: true,
    default: './migrations',
})
    .option('migration-out-dir', {
    description: 'The output directory for migration files (when using a transpiler)',
    nargs: 1,
    global: true,
    default: './migrations',
})
    .option('no-color', { desc: 'Disable colored output', global: true })
    .option('color', {
    desc: 'Force colored output even if color support was not detected',
    global: true,
})
    .version(pkg.version)
    .alias('version', 'v')
    .help('help')
    .alias('help', 'h')
    .epilogue('All options can also be passed through env vars, like MERKEL_DB for --db');
yargs.command('init', 'Initializes merkel configuration interactively', { db: Object.assign({}, dbOption, { require: false }) }, (argv) => __awaiter(this, void 0, void 0, function* () {
    try {
        process.stdout.write('\n');
        if (yield index_1.isMerkelRepository()) {
            process.stderr.write('.merkelrc.json already exists\n');
            process.exit(1);
        }
        // try to read tsconfig
        let tsconfig;
        try {
            tsconfig = JSON.parse(yield fs.readFile('tsconfig.json', 'utf8'));
        }
        catch (err) {
            // ignore
        }
        const { migrationDir, migrationOutDir, shouldAddGitHook, initMetaNow } = yield inquirer.prompt([
            {
                name: 'migrationDir',
                message: tsconfig ? 'Directory for new migration files:' : 'Directory for migration files:',
                default: (tsconfig &&
                    tsconfig.compilerOptions &&
                    tsconfig.compilerOptions.rootDir &&
                    tsconfig.compilerOptions.rootDir + path.sep + 'migrations') ||
                    './migrations',
            },
            {
                name: 'migrationOutDir',
                message: 'Directory for compiled migration files:',
                default: (tsconfig &&
                    tsconfig.compilerOptions &&
                    tsconfig.compilerOptions.outDir &&
                    tsconfig.compilerOptions.outDir + path.sep + 'migrations') ||
                    './migrations',
                when: () => !!tsconfig,
            },
            {
                name: 'shouldAddGitHook',
                type: 'confirm',
                message: 'Add a git hook that adds commands to your commit messages (you can still edit them)?',
            },
            {
                name: 'initMetaNow',
                type: 'confirm',
                message: 'Initialize merkel metadata table now (otherwise done automatically later)?',
                when: () => !!argv.db,
            },
        ]);
        if (yield index_1.createMigrationDir(migrationDir)) {
            process.stdout.write(`Created ${chalk_1.default.cyan(migrationDir)}\n`);
        }
        yield index_1.createConfig({
            migrationDir,
            migrationOutDir: migrationOutDir || './migrations',
        });
        process.stdout.write(`Created ${chalk_1.default.cyan(path.join('.', '.merkelrc.json'))}\n`);
        if (initMetaNow) {
            yield adapter_1.createAdapterFromUrl(argv.db).init();
        }
        // add git hook
        if (shouldAddGitHook) {
            try {
                const [type, hookPath] = yield git_2.addGitHook();
                switch (type) {
                    case 'appended':
                        process.stdout.write(`Appended hook to ${chalk_1.default.cyan(hookPath)}\n`);
                        break;
                    case 'created':
                        process.stdout.write(`Created ${chalk_1.default.cyan(hookPath)}\n`);
                }
            }
            catch (err) {
                if (err instanceof git_2.HookAlreadyFoundError) {
                    process.stdout.write('Hook already found\n');
                    process.exit(0);
                }
                else {
                    throw err;
                }
            }
        }
        process.exit(0);
    }
    catch (err) {
        process.stdout.write(chalk_1.default.red(err.stack));
        process.exit(1);
    }
}));
yargs.command('add-git-hook', 'Adds a prepare-commit-msg hook to git that automatically adds merkel commands to your commit messages', {}, () => __awaiter(this, void 0, void 0, function* () {
    try {
        process.stdout.write('\n');
        const [type, hookPath] = yield git_2.addGitHook();
        switch (type) {
            case 'appended':
                process.stdout.write(`Appended hook to ${chalk_1.default.cyan(hookPath)}\n`);
                break;
            case 'created':
                process.stdout.write(`Created ${chalk_1.default.cyan(hookPath)}\n`);
        }
        process.exit(0);
    }
    catch (err) {
        if (err instanceof git_2.HookAlreadyFoundError) {
            process.stdout.write(chalk_1.default.red('Hook already found\n'));
            process.exit(0);
            return;
        }
        process.stderr.write(chalk_1.default.red(err.stack));
        process.exit(1);
    }
}));
yargs.command('prepare-commit-msg <msgfile> [source] [sha1]', false, {
    migrationDir: {
        demandOption: true,
    },
}, (argv) => __awaiter(this, void 0, void 0, function* () {
    try {
        if (argv.source !== 'message') {
            yield index_1.prepareCommitMsg(argv.msgfile, argv.migrationDir);
        }
        process.exit(0);
    }
    catch (err) {
        process.stderr.write(chalk_1.default.red(err.stack));
        process.exit(1);
    }
}));
yargs.command('status', 'Shows the last migration task and new migrations tasks to execute', { db: dbOption }, (argv) => __awaiter(this, void 0, void 0, function* () {
    try {
        const adapter = adapter_1.createAdapterFromUrl(argv.db);
        yield adapter.init();
        const head = yield git_1.getHead();
        // wait for current migration to finish
        yield adapter.waitForPending(index_1.CLI_LOGGER);
        const status = yield index_1.getStatus(adapter, head);
        process.stdout.write('\n' + status.toString());
        if (status.newCommits.some(commit => commit.tasks.length > 0)) {
            process.stdout.write(`Run ${chalk_1.default.white.bold('merkel migrate')} to execute\n`);
        }
        process.exit(0);
    }
    catch (err) {
        process.stderr.write(chalk_1.default.red(err.stack));
        process.exit(1);
    }
}));
yargs.command('migrate', 'Runs all migration tasks that were embedded in commit messages since the commit of the last migration', {
    confirm: {
        type: 'boolean',
        description: 'Ask for confirmation before beginning the actual migration',
        default: process.stdin.isTTY,
        defaultDescription: 'true if run in TTY context',
    },
    db: dbOption,
}, (argv) => __awaiter(this, void 0, void 0, function* () {
    try {
        const adapter = adapter_1.createAdapterFromUrl(argv.db);
        yield adapter.init();
        outerLoop: while (true) {
            const head = yield git_1.getHead();
            const status = yield index_1.getStatus(adapter, head);
            process.stdout.write(status.toString());
            const tasks = status.newCommits.reduce((prev, next) => prev.concat(next.tasks), []);
            if (tasks.length > 0) {
                if (argv.confirm) {
                    const answer = yield inquirer.prompt({
                        type: 'confirm',
                        name: 'continue',
                        message: 'Continue?',
                    });
                    if (!answer.continue) {
                        process.exit(0);
                    }
                    process.stdout.write('\n');
                }
                process.stdout.write('Starting migration\n\n');
                const hasChanged = yield adapter.waitForPending(index_1.CLI_LOGGER);
                if (hasChanged) {
                    process.stdout.write('The pending migrations have changed, reloading..\n\n');
                    continue;
                }
                for (const commit of status.newCommits) {
                    process.stdout.write(`${chalk_1.default.yellow(commit.shortSha1)} ${commit.subject}\n`);
                    for (const task of commit.tasks) {
                        try {
                            task.head = head;
                            yield adapter.beginMigrationTask(task);
                        }
                        catch (error) {
                            if (error instanceof index_1.PendingMigrationFoundError) {
                                continue outerLoop;
                            }
                            else {
                                throw error;
                            }
                        }
                        process.stdout.write(task.toString() + ' ...');
                        const interval = setInterval(() => process.stdout.write('.'), 100);
                        try {
                            yield task.execute(argv.migrationOutDir, adapter, head, commit);
                        }
                        finally {
                            clearInterval(interval);
                        }
                        process.stdout.write(' Success\n');
                    }
                }
                process.stdout.write(chalk_1.default.green('\nAll migrations successful\n'));
            }
            break;
        }
        process.exit(0);
    }
    catch (err) {
        process.stderr.write('\n' + chalk_1.default.red(err.stack));
        process.exit(1);
    }
}));
const migrationCommand = (type) => (argv) => __awaiter(this, void 0, void 0, function* () {
    try {
        const adapter = adapter_1.createAdapterFromUrl(argv.db);
        yield adapter.init();
        const tasks = argv.migrations.map(name => new migration_1.Task({ type, migration: new migration_1.Migration(name) }));
        while (true) {
            if (yield adapter.waitForPending(index_1.CLI_LOGGER)) {
                process.stdout.write('The pending migrations have changed, reloading..\n\n');
                // retry
                continue;
            }
            const head = yield git_1.getHead();
            for (const task of tasks) {
                try {
                    task.head = head;
                    yield adapter.beginMigrationTask(task);
                }
                catch (error) {
                    if (error instanceof index_1.PendingMigrationFoundError) {
                        continue;
                    }
                    else {
                        throw error;
                    }
                }
            }
            for (const task of tasks) {
                process.stdout.write(`${task.toString()} ...`);
                const interval = setInterval(() => process.stdout.write('.'), 100);
                try {
                    yield task.execute(argv.migrationOutDir, adapter, head);
                }
                finally {
                    clearInterval(interval);
                }
                process.stdout.write(' Success\n');
            }
            process.stdout.write('\n' + chalk_1.default.green.bold('Migration successful') + '\n');
            break;
        }
    }
    catch (err) {
        process.stderr.write('\n' + chalk_1.default.red(err.stack));
        process.exit(1);
    }
    process.exit(0);
});
yargs.command('up <migrations..>', 'Migrates specific migrations up', { db: dbOption }, migrationCommand('up'));
yargs.command('down <migrations..>', 'Migrates specific migrations down', { db: dbOption }, migrationCommand('down'));
yargs.command('generate', 'Generates a new migration file', {
    name: {
        alias: 'n',
        nargs: 1,
        description: 'The name of the migration file',
        defaultDescription: 'UUID',
    },
    template: {
        alias: 't',
        nargs: 1,
        description: 'The path to a custom template file that should be used',
    },
}, (argv) => __awaiter(this, void 0, void 0, function* () {
    try {
        let migrationDir;
        if (argv.migrationDir) {
            migrationDir = path.resolve(argv.migrationDir);
        }
        else {
            const configuration = yield index_1.getConfigurationForCommit(yield git_1.getHead());
            if (configuration) {
                migrationDir = configuration.migrationDir;
            }
        }
        if (!migrationDir) {
            throw new MigrationDirNotSpecifiedError();
        }
        yield index_1.generate({
            name: argv.name,
            migrationDir,
            template: argv.template,
        });
        process.exit(0);
    }
    catch (err) {
        process.stderr.write(chalk_1.default.red(err.stack));
        process.exit(1);
    }
}));
yargs.completion('completion');
exports.default = yargs;
//# sourceMappingURL=cli.js.map