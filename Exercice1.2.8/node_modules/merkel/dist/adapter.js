"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const url_1 = require("url");
const git_1 = require("./git");
const migration_1 = require("./migration");
class InvalidConnectionError extends Error {
    constructor(url) {
        super('Invalid connection URL ' + url);
    }
}
exports.InvalidConnectionError = InvalidConnectionError;
class UnsupportedDialectError extends Error {
    constructor(dialect) {
        super('Unsupported dialect: ' + dialect);
    }
}
exports.UnsupportedDialectError = UnsupportedDialectError;
class PendingMigrationTimedOutError extends Error {
    constructor() {
        super(...arguments);
        /* istanbul ignore next */
        this.name = 'PendingMigrationTimedOutError';
    }
}
exports.PendingMigrationTimedOutError = PendingMigrationTimedOutError;
class PendingMigrationFoundError extends Error {
    constructor() {
        super(...arguments);
        /* istanbul ignore next */
        this.name = 'PendingMigrationFoundError';
    }
}
exports.PendingMigrationFoundError = PendingMigrationFoundError;
class DbAdapter {
    waitForPending(logger) {
        return __awaiter(this, void 0, void 0, function* () {
            let wasPending = false;
            let shouldRetry = true;
            yield Promise.race([
                new Promise((_, reject) => setTimeout(() => reject(new PendingMigrationTimedOutError()), 1000 * 60 * 10)),
                (() => __awaiter(this, void 0, void 0, function* () {
                    // fail after 10 min
                    let interval;
                    while (shouldRetry) {
                        // if there are rows, a migration is already running
                        if (!(yield this.hasPendingMigration())) {
                            if (wasPending) {
                                logger.log('\n\n');
                            }
                            break;
                        }
                        if (!wasPending) {
                            logger.log(`${chalk_1.default.yellow('Waiting for pending migrations')} ...`);
                            // we had to wait for at least 1 pending migration
                            wasPending = true;
                            interval = setInterval(() => logger.log('.'), 300);
                        }
                        // wait for 1000ms before retrying
                        yield new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    if (interval) {
                        clearInterval(interval);
                    }
                }))(),
            ]);
            shouldRetry = false;
            return wasPending;
        });
    }
    rowToTask(row) {
        const task = new migration_1.Task({
            id: row.id,
            type: row.type,
            migration: new migration_1.Migration(row.name),
            commit: row.commit ? new git_1.Commit({ sha1: row.commit }) : undefined,
            head: new git_1.Commit({ sha1: row.head }),
            appliedAt: row.applied_at || undefined,
        });
        return task;
    }
}
exports.DbAdapter = DbAdapter;
const postgres_1 = require("./adapters/postgres");
function createAdapterFromUrl(url) {
    const dialect = url_1.parse(url).protocol;
    switch (dialect) {
        case 'postgres:':
            try {
                return new postgres_1.PostgresAdapter(url, require(process.cwd() + '/node_modules/pg'));
            }
            catch (err) {
                /* istanbul ignore next */
                return new postgres_1.PostgresAdapter(url, require('pg'));
            }
        case null:
            throw new InvalidConnectionError(url);
        default:
            throw new UnsupportedDialectError(dialect);
    }
}
exports.createAdapterFromUrl = createAdapterFromUrl;
//# sourceMappingURL=adapter.js.map