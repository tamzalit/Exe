"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const child_process_1 = require("mz/child_process");
const fs = require("mz/fs");
const path = require("path");
const path_1 = require("path");
const migration_1 = require("./migration");
class HookAlreadyFoundError extends Error {
}
exports.HookAlreadyFoundError = HookAlreadyFoundError;
class NoCommitsError extends Error {
}
exports.NoCommitsError = NoCommitsError;
class UnknownCommitError extends Error {
    constructor(commit) {
        super(`The commit ${commit.shortSha1} does not exist in this repository. Did you do a shallow clone?`);
    }
}
exports.UnknownCommitError = UnknownCommitError;
class GitParseError extends Error {
}
exports.GitParseError = GitParseError;
class CommitSequence extends Array {
    constructor() {
        super(...arguments);
        /**
         * Wether the HEAD commit was before the last migration HEAD commit
         */
        this.isReversed = false;
    }
}
exports.CommitSequence = CommitSequence;
class Commit {
    /** The first 6 letters of the SHA1 */
    get shortSha1() {
        return this.sha1.substring(0, 7);
    }
    /** The first line of the commit message */
    get subject() {
        return this.message && this.message.split('\n', 1)[0];
    }
    constructor(options) {
        this.sha1 = options.sha1;
        this.message = options.message;
        this.tasks = options.tasks || new migration_1.TaskList();
    }
    /**
     * Loads more info by using `git show <sha1>`
     */
    loadSubject() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.message === undefined) {
                const [stdout] = yield child_process_1.execFile('git', ['show', '--format=%B', '--no-patch', this.sha1]);
                this.message = stdout.toString();
            }
        });
    }
    toString() {
        return chalk_1.default.yellow.bold(this.shortSha1) + ' ' + (this.subject ? this.subject : '<unknown commit>');
    }
}
exports.Commit = Commit;
function hasHead() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield child_process_1.execFile('git', ['show', '--format=%H', '--no-patch', 'HEAD']);
            return true;
        }
        catch (err) {
            return false;
        }
    });
}
/**
 * Gets all commits in the migration dir since the last migration head
 * @param from The commit sha1 of the commit when the last migration was running
 */
function getNewCommits(since) {
    return __awaiter(this, void 0, void 0, function* () {
        if (since) {
            try {
                yield child_process_1.execFile('git', ['show', '--format=%H', '--no-patch', since.sha1]);
            }
            catch (err) {
                // the last migration head does not exist in this repository
                throw new UnknownCommitError(since);
            }
        }
        if (!(yield hasHead())) {
            return new CommitSequence();
        }
        // check if the HEAD is behind the last migration
        let headBehindLastMigration = false;
        if (since) {
            try {
                yield child_process_1.execFile('git', ['merge-base', '--is-ancestor', since.sha1, 'HEAD']);
            }
            catch (err) {
                /* istanbul ignore next */
                if (err.code !== 1) {
                    throw err;
                }
                headBehindLastMigration = true;
            }
        }
        const args = ['log', '--reverse', '--format=>>>>COMMIT%n%H%n%B'];
        if (since) {
            args.push(headBehindLastMigration ? 'HEAD..' + since.sha1 : since.sha1 + '..HEAD');
        }
        const commits = yield new Promise((resolve, reject) => {
            const gitProcess = child_process_1.spawn('git', args);
            let buffer = '';
            const parsedCommits = new CommitSequence();
            gitProcess.stdout.on('data', data => {
                buffer += data.toString().trim();
                const commitMarkerIndex = buffer.lastIndexOf('>>>>COMMIT\n');
                if (commitMarkerIndex !== -1) {
                    const completeCommits = buffer.substring(0, commitMarkerIndex);
                    buffer = buffer.substring(commitMarkerIndex);
                    const parsedLog = parseGitLog(completeCommits);
                    for (const commit of parsedLog) {
                        parsedCommits.push(commit);
                    }
                }
            });
            let errorBuffer = '';
            gitProcess.stderr.on('data', data => {
                /* istanbul ignore next */
                errorBuffer += data.toString();
            });
            gitProcess.on('error', reject);
            gitProcess.on('exit', code => {
                /* istanbul ignore next */
                if (code !== 0) {
                    reject(new Error(`git errored: ${code}\n${errorBuffer}`));
                }
                const parsedLog = parseGitLog(buffer);
                for (const commit of parsedLog) {
                    parsedCommits.push(commit);
                }
                resolve(parsedCommits);
            });
        });
        commits.isReversed = headBehindLastMigration;
        return commits;
    });
}
exports.getNewCommits = getNewCommits;
function getConfigurationForCommit(commit) {
    return __awaiter(this, void 0, void 0, function* () {
        if (commit.sha1) {
            try {
                const [merkelRc] = yield child_process_1.execFile('git', ['show', `${commit.sha1}:.merkelrc.json`]);
                const merkelConfig = JSON.parse(merkelRc);
                if (merkelConfig) {
                    return merkelConfig;
                }
            }
            catch (err) {
                /* istanbul ignore next */
                if (~~err.code !== 128) {
                    throw err;
                }
                // no merkelrc in this commit
            }
        }
        return null;
    });
}
exports.getConfigurationForCommit = getConfigurationForCommit;
function addGitHook() {
    return __awaiter(this, void 0, void 0, function* () {
        const hookPath = path.normalize('.git/hooks/prepare-commit-msg');
        const hook = ['', 'PATH="$(pwd)/node_modules/merkel/bin:$PATH"', 'merkel prepare-commit-msg $1 $2 $3', ''].join('\n');
        let content;
        try {
            content = yield fs.readFile(hookPath, 'utf8');
        }
        catch (err) {
            yield fs.writeFile(hookPath, '#!/bin/sh\n' + hook);
            return ['created', hookPath];
        }
        if (content && content.indexOf(hook.substring(1, hook.length - 1)) !== -1) {
            throw new HookAlreadyFoundError();
        }
        yield fs.appendFile(hookPath, hook);
        return ['appended', hookPath];
    });
}
exports.addGitHook = addGitHook;
/**
 * Parses the output of `git log --reverse --format=">>>>COMMIT%n%H%n%B" ${lastMigrationHead}`.
 */
function parseGitLog(gitLog) {
    if (gitLog === '') {
        return new CommitSequence();
    }
    // drop first occurrence of ">>>>COMMIT" and split the remainder
    const commitStrings = gitLog.substr('>>>>COMMIT\n'.length).split('>>>>COMMIT\n');
    const commits = new CommitSequence();
    for (const s of commitStrings) {
        const splitMatch = s.match(/^(\w+)\n((?:.|\n|\r)*)$/);
        if (!splitMatch) {
            /* istanbul ignore next */
            throw new GitParseError();
        }
        let [, sha1, message] = splitMatch;
        message = message.trim();
        // get commands from message
        const regExp = /\[\s*merkel[^\]]*\s*\]/g;
        const match = message.match(regExp);
        const commands = match
            ? match.map(command => command
                .replace(/^\s*\[\s*/, '')
                .replace(/\s*\]\s*$/, '')
                .split(/\s+/g)
                .slice(1))
            : [];
        // strip commands from message
        const commit = new Commit({ sha1, message: message.replace(regExp, '').trim() });
        for (const command of commands) {
            const type = command.shift();
            for (const name of command) {
                commit.tasks.push(new migration_1.Task({ type, migration: new migration_1.Migration(name), commit }));
            }
        }
        commits.push(commit);
    }
    return commits;
}
exports.parseGitLog = parseGitLog;
/**
 * Gets the SHA1 of the current git HEAD
 */
function getHead() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const [stdout] = yield child_process_1.execFile('git', ['rev-parse', 'HEAD']);
            return new Commit({ sha1: stdout.trim() });
        }
        catch (err) {
            throw new NoCommitsError(err.message);
        }
    });
}
exports.getHead = getHead;
/* Returns all migrations that have been (A)dded in the current commit */
function getTasksForNewCommit(migrationDir) {
    return __awaiter(this, void 0, void 0, function* () {
        migrationDir = path_1.resolve(migrationDir);
        const [stdout] = yield child_process_1.execFile('git', ['diff', '--staged', '--name-status']);
        const output = stdout.toString().trim();
        const tasks = new migration_1.TaskList();
        // added migration files should be executed up
        for (const line of output.split('\n')) {
            const status = line.charAt(0);
            const file = path_1.resolve(line.substr(1).trim());
            if (status === 'A' && file.startsWith(migrationDir)) {
                const name = path_1.basename(file).replace(/\.\w*$/, '');
                tasks.push(new migration_1.Task({ type: 'up', migration: new migration_1.Migration(name) }));
            }
        }
        return tasks;
    });
}
exports.getTasksForNewCommit = getTasksForNewCommit;
function isRevertCommit(message) {
    return /Revert/.test(message);
}
exports.isRevertCommit = isRevertCommit;
//# sourceMappingURL=git.js.map