"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const sql_template_strings_1 = require("sql-template-strings");
const adapter_1 = require("../adapter");
const migration_1 = require("../migration");
class PostgresAdapter extends adapter_1.DbAdapter {
    /**
     * @param url The connection url
     * @param lib The pg library
     */
    constructor(url, lib) {
        super();
        this.lib = lib;
        this.client = new this.lib.Client({ connectionString: url });
    }
    /**
     * Connects to the database and sets up the schema if required
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => this.client.connect(err => (err ? reject(err) : resolve())));
            yield this.client.query(`
            DO $$
            BEGIN
                IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'merkel_migration_type') THEN
                    CREATE TYPE "merkel_migration_type" AS ENUM ('up', 'down');
                END IF;
            END$$
        `);
            yield this.client.query(`
            CREATE TABLE IF NOT EXISTS "merkel_meta" (
                "id" SERIAL NOT NULL PRIMARY KEY,
                "name" TEXT NOT NULL,
                "type" merkel_migration_type NOT NULL,
                "commit" TEXT,
                "head" TEXT NOT NULL,
                "applied_at" TIMESTAMP WITH TIME ZONE
            );
        `);
            // migrate schema from merkel <= 0.19
            yield this.client.query(`ALTER TABLE "merkel_meta" ALTER COLUMN "applied_at" DROP NOT NULL`);
        });
    }
    close() {
        return new Promise(resolve => {
            this.client.on('end', resolve);
            // tslint:disable-next-line:no-floating-promises
            this.client.end();
        });
    }
    /**
     * Gets the last migration task that was executed
     */
    getLastMigrationTask() {
        return __awaiter(this, void 0, void 0, function* () {
            // find out the current database state
            const { rows } = yield this.client.query(`
            SELECT "id", "name", "applied_at", "type", "commit", "head"
            FROM "merkel_meta"
            WHERE "applied_at" IS NOT NULL
            ORDER BY "id" DESC
            LIMIT 1
        `);
            return rows.length === 0 ? null : this.rowToTask(rows[0]);
        });
    }
    /**
     * Logs a task to the database. Sets the task ID
     */
    beginMigrationTask(task) {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!task.head) {
                throw new Error('Task has no HEAD');
            }
            yield this.client.query(`BEGIN TRANSACTION`);
            try {
                yield this.client.query(`LOCK TABLE "merkel_meta"`);
                if (yield this.hasPendingMigration()) {
                    /* istanbul ignore next */
                    throw new adapter_1.PendingMigrationFoundError();
                }
                const { rows } = yield this.client.query(sql_template_strings_1.SQL `
                INSERT INTO merkel_meta ("name", "type", "commit", "head")
                VALUES (
                    ${task.migration.name},
                    ${task.type},
                    ${task.commit ? task.commit.sha1 : null},
                    ${task.head.sha1}
                )
                RETURNING id
            `);
                yield this.client.query(`COMMIT`);
                task.id = rows[0].id;
            }
            finally {
                yield this.client.query(`ROLLBACK`);
            }
        });
    }
    /**
     * Marks the task as finished
     */
    finishMigrationTask(task) {
        return __awaiter(this, void 0, void 0, function* () {
            const head = task.head ? task.head.sha1 : null;
            const commit = task.commit ? task.commit.sha1 : null;
            yield this.client.query(sql_template_strings_1.SQL `
            UPDATE merkel_meta
            SET
                "applied_at" = ${task.appliedAt},
                "head" = ${head},
                "commit" = ${commit}
            WHERE "id" = ${task.id}
        `);
        });
    }
    /**
     * Checks that the same task cannot be executed two times in a row and the first task cannot be
     * a down task
     */
    checkIfTaskCanExecute(task) {
        return __awaiter(this, void 0, void 0, function* () {
            const { rows } = yield this.client.query(sql_template_strings_1.SQL `
            SELECT "type"
            FROM "merkel_meta"
            WHERE "name" = ${task.migration.name}
            AND "applied_at" IS NOT NULL
            ORDER BY "id" DESC
            LIMIT 1
        `);
            if (task.type === 'up') {
                if (rows.length > 0 && rows[0].type === 'up') {
                    throw new migration_1.MigrationRunTwiceError(task.migration, 'up');
                }
            }
            else if (task.type === 'down') {
                if (rows.length === 0) {
                    throw new migration_1.FirstDownMigrationError(task.migration);
                }
                else if (rows[0].type === 'down') {
                    throw new migration_1.MigrationRunTwiceError(task.migration, 'down');
                }
            }
        });
    }
    hasPendingMigration() {
        return __awaiter(this, void 0, void 0, function* () {
            const { rows } = yield this.client.query(sql_template_strings_1.SQL `
            SELECT "type"
            FROM "merkel_meta"
            WHERE "applied_at" IS NULL
            LIMIT 1
        `);
            return rows.length !== 0;
        });
    }
}
exports.PostgresAdapter = PostgresAdapter;
//# sourceMappingURL=postgres.js.map