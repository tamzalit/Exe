"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const mkdirp = require("mkdirp");
const fs = require("mz/fs");
const path = require("path");
const uuidv1 = require("uuid/v1");
const git_1 = require("./git");
const git_2 = require("./git");
__export(require("./git"));
__export(require("./migration"));
__export(require("./adapter"));
__export(require("./adapters/postgres"));
/* istanbul ignore next */
exports.CLI_LOGGER = {
    log: (log) => process.stdout.write(log),
    error: (log) => process.stderr.write(log),
    warn: (log) => process.stderr.write(log),
};
/* istanbul ignore next */
exports.SILENT_LOGGER = {
    log: () => undefined,
    warn: () => undefined,
    error: () => undefined,
};
class TemplateNotFoundError extends Error {
    constructor(templateDir) {
        super('Could not find template ' + templateDir);
    }
}
exports.TemplateNotFoundError = TemplateNotFoundError;
class Status {
    constructor(options) {
        /** The last migration task that was executed, according to the merkel metadata table */
        this.lastTask = null;
        this.head = options.head;
        this.newCommits = options.newCommits;
        this.lastTask = options.lastTask;
    }
    /** Executes all tasks for newCommits */
    executePendingTasks(migrationDir, adapter, logger = exports.CLI_LOGGER) {
        return __awaiter(this, void 0, void 0, function* () {
            while (true) {
                logger.log(this.toString());
                const tasks = this.newCommits.reduce((prev, next) => prev.concat(next.tasks), []);
                if (tasks.length > 0) {
                    logger.log('Starting migration\n\n');
                    const hasChanged = yield adapter.waitForPending(logger);
                    if (hasChanged) {
                        logger.log('The pending migrations have changed, reloading..\n\n');
                        continue;
                    }
                    // create pending tasks
                    for (const task of tasks) {
                        task.head = this.head;
                        yield adapter.beginMigrationTask(task);
                    }
                    for (const commit of this.newCommits) {
                        logger.log(`${chalk_1.default.yellow.bold(commit.shortSha1)} ${commit.subject}\n`);
                        for (const task of commit.tasks) {
                            logger.log(task.toString() + ' ...');
                            const interval = setInterval(() => logger.log('.'), 100);
                            try {
                                yield task.execute(migrationDir, adapter, this.head, commit);
                            }
                            finally {
                                clearInterval(interval);
                            }
                            logger.log(' Success\n');
                        }
                    }
                    logger.log(chalk_1.default.green('\nAll migrations successful\n'));
                }
                break;
            }
        });
    }
    /** Returns a string that can be printed to a CLI */
    toString() {
        let str = '';
        if (this.lastTask) {
            str += `Last migration:      ${this.lastTask.toString()}\n`;
            str += `Applied at:          ${this.lastTask.appliedAt}\n`;
            if (this.lastTask.commit) {
                str += `Triggered by commit: ${this.lastTask.commit.toString()}\n`;
            }
            if (this.lastTask.head) {
                str += `HEAD at execution:   ${this.lastTask.head.toString()}\n`;
            }
        }
        else {
            str += `Last migration:      No migration run yet\n`;
        }
        if (this.head) {
            str += chalk_1.default.grey(`                        ${this.newCommits.length === 0
                ? '‖'
                : `${this.newCommits.isReversed ? '↑' : '↓'} ${this.newCommits.length} commit${this.newCommits.length > 1 ? 's' : ''}`}\n`);
            str += `Current HEAD:        ${this.head.toString()}\n`;
        }
        str += '\n';
        const relevantCommits = this.newCommits.filter(commit => commit.tasks.length > 0);
        if (relevantCommits.length === 0) {
            str += 'No pending migrations\n';
            return str;
        }
        const migrationCount = relevantCommits.reduce((prev, curr) => prev + curr.tasks.length, 0);
        str += chalk_1.default.underline(`${migrationCount} pending migration${migrationCount > 1 ? 's' : ''}:\n\n`);
        for (const commit of relevantCommits) {
            str += commit.toString() + '\n';
            for (const task of commit.tasks) {
                str += (this.newCommits.isReversed ? task.invert() : task).toString() + '\n';
            }
            str += `\n`;
        }
        return str;
    }
}
exports.Status = Status;
/**
 * Returns an object with information about the current status of the repository
 * @param adapter the database adapter to use. Create one with [[createAdapterFromUrl]]
 * @param head The current HEAD commit. If not given, will ask git
 */
function getStatus(adapter, head) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!head) {
            head = yield git_2.getHead();
        }
        const lastTask = yield adapter.getLastMigrationTask();
        let newCommits;
        if (lastTask) {
            newCommits = yield git_1.getNewCommits(lastTask.head);
            // Load commit messages
            yield Promise.all([lastTask.commit, lastTask.head]
                .filter((commit) => !!commit)
                .map((commit) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield commit.loadSubject();
                }
                catch (err) {
                    /* istanbul ignore next */
                    if (err.code !== 128) {
                        throw err;
                    }
                }
            })));
        }
        else {
            newCommits = yield git_1.getNewCommits();
        }
        if (head) {
            yield head.loadSubject();
        }
        return new Status({ head, newCommits, lastTask });
    });
}
exports.getStatus = getStatus;
/**
 * Checks if a folder has a .merkelrc.json file
 */
function isMerkelRepository() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fs.access('.merkelrc.json');
            return true;
        }
        catch (err) {
            return false;
        }
    });
}
exports.isMerkelRepository = isMerkelRepository;
/**
 * Creates the migration directory
 */
function createMigrationDir(migrationDir) {
    return new Promise((resolve, reject) => mkdirp(migrationDir, (err, made) => 
    /* istanbul ignore next */
    err ? reject(err) : resolve(!!made)));
}
exports.createMigrationDir = createMigrationDir;
/**
 * Creates a new .merkelrc.json
 */
function createConfig(config) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fs.writeFile('.merkelrc.json', JSON.stringify(config, null, 2) + '\n');
    });
}
exports.createConfig = createConfig;
/**
 * Prepares a commit message for git by adding merkel commands to it.
 * @param msgfile The path to the file with the commit message
 */
function prepareCommitMsg(msgfile, migrationDir, logger = exports.CLI_LOGGER) {
    return __awaiter(this, void 0, void 0, function* () {
        const msg = yield fs.readFile(msgfile, 'utf8');
        // check that migrations have not been deleted by a revert
        if (git_2.isRevertCommit(msg)) {
            logger.warn(chalk_1.default.bgYellow('WARNING: migrations have been removed by a git revert'));
        }
        // add commands
        const taskList = yield git_2.getTasksForNewCommit(migrationDir);
        yield fs.appendFile(msgfile, '\n' + taskList.toString(true));
    });
}
exports.prepareCommitMsg = prepareCommitMsg;
class MigrationAlreadyExistsError extends Error {
    constructor(file) {
        super('Migration file already existed: ' + file);
    }
}
exports.MigrationAlreadyExistsError = MigrationAlreadyExistsError;
/**
 * Generates a new migration file
 */
function generate(options, logger = exports.CLI_LOGGER) {
    return __awaiter(this, void 0, void 0, function* () {
        options.name = options.name || uuidv1();
        let template;
        let ext = '';
        if (options.template) {
            try {
                template = yield fs.readFile(options.template, 'utf8');
            }
            catch (err) {
                /* istanbul ignore if */
                if (err.code !== 'ENOENT') {
                    throw err;
                }
                throw new TemplateNotFoundError(options.template);
            }
        }
        else {
            // detect tsconfig.json
            try {
                const tsconfig = JSON.parse(yield fs.readFile('tsconfig.json', 'utf8'));
                const targetLessThanEs6 = tsconfig.compilerOptions && /^es[35]$/i.test(tsconfig.compilerOptions.target);
                ext = '.ts';
                template = [
                    '',
                    `export ${targetLessThanEs6 ? '' : 'async '}function up(): Promise<void> {`,
                    '',
                    '}',
                    '',
                    `export ${targetLessThanEs6 ? '' : 'async '}function down(): Promise<void> {`,
                    '',
                    '}',
                    '',
                ].join('\n');
            }
            catch (err) {
                /* istanbul ignore if */
                if (err.code !== 'ENOENT') {
                    throw err;
                }
                ext = '.js';
                template = [
                    '',
                    'exports.up = function up() {',
                    '',
                    '};',
                    '',
                    'exports.down = function down() {',
                    '',
                    '};',
                    '',
                ].join('\n');
            }
        }
        const file = `${options.migrationDir}/${options.name}${ext}`;
        const relativePath = path.relative(process.cwd(), options.migrationDir);
        // check if already exists
        try {
            yield fs.access(file);
            logger.error(chalk_1.default.red('\nError: Migration file ' +
                relativePath +
                path.sep +
                chalk_1.default.bold(options.name) +
                ext +
                ' already exists\n'));
            throw new MigrationAlreadyExistsError(file);
        }
        catch (err) {
            if (err instanceof MigrationAlreadyExistsError) {
                throw err;
            }
            // continue
        }
        yield new Promise((resolve, reject) => mkdirp(options.migrationDir, err => (err ? reject(err) : resolve())));
        yield fs.writeFile(file, template);
        logger.log('\nCreated ' + chalk_1.default.cyan(relativePath + path.sep + options.name + ext) + '\n');
        return options.name;
    });
}
exports.generate = generate;
//# sourceMappingURL=index.js.map