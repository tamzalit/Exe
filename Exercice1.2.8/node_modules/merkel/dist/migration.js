"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const fs = require("mz/fs");
const path_1 = require("path");
const git_1 = require("./git");
class MigrationLoadError extends Error {
    constructor(migration, migrationDir, error) {
        super('Error loading migration file ' + migrationDir + path_1.sep + chalk_1.default.bold(migration.name) + '.js:\n' + error);
        this.migration = migration;
        this.migrationDir = migrationDir;
        this.error = error;
    }
}
exports.MigrationLoadError = MigrationLoadError;
class FirstDownMigrationError extends Error {
    constructor(migration) {
        super(`The first migration cannot be a down migration (${migration.name})`);
        this.migration = migration;
    }
}
exports.FirstDownMigrationError = FirstDownMigrationError;
class MigrationRunTwiceError extends Error {
    constructor(migration, type) {
        super(`Tried to run the same migration (${migration.name}) ${type} twice`);
        this.migration = migration;
        this.type = type;
    }
}
exports.MigrationRunTwiceError = MigrationRunTwiceError;
class MigrationNotFoundError extends Error {
    constructor(migration, migrationDir) {
        super('Migration file ' + migrationDir + path_1.sep + chalk_1.default.bold(migration.name) + '.js does not exist');
        this.migration = migration;
        this.migrationDir = migrationDir;
    }
}
exports.MigrationNotFoundError = MigrationNotFoundError;
class TaskTypeNotFoundError extends Error {
    constructor(migration, taskType, migrationDir) {
        super('Migration file ' + migrationDir + path_1.sep + chalk_1.default.bold(migration.name) + '.js does not export an up function');
        this.migration = migration;
        this.taskType = taskType;
        this.migrationDir = migrationDir;
    }
}
exports.TaskTypeNotFoundError = TaskTypeNotFoundError;
class MigrationExecutionError extends Error {
    constructor(original) {
        super(chalk_1.default.red(chalk_1.default.bold('Migration error: ') + original.stack || original));
        this.original = original;
    }
}
exports.MigrationExecutionError = MigrationExecutionError;
class UnknownTaskTypeError extends Error {
    constructor(type) {
        super('Unknown migration type ' + type);
    }
}
exports.UnknownTaskTypeError = UnknownTaskTypeError;
class Migration {
    constructor(
    /** The name of the migration */
    name) {
        this.name = name;
    }
    /**
     * @param migrationDir The migration directory
     */
    getPath(migrationDir) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = path_1.resolve(migrationDir, (this.name || '') + '.js');
            try {
                yield fs.access(file);
                return file;
            }
            catch (err) {
                throw new MigrationNotFoundError(this, migrationDir);
            }
        });
    }
}
exports.Migration = Migration;
class TaskList extends Array {
    /**
     * Converts the task list to a string of commands that can be embedded in a commit message
     */
    toString(withComment = false) {
        let str = '';
        if (this.length > 0) {
            if (withComment) {
                str += '# Merkel migrations that need to run after checking out this commit:\n';
            }
            for (const type of ['up', 'down']) {
                const tasks = this.filter(task => task.type === type);
                if (tasks.length === 0) {
                    continue;
                }
                let command = `[merkel ${type} ${tasks.map(task => task.migration.name).join(' ')}]\n`;
                if (command.length > 72) {
                    command = `[\n  merkel ${type}\n  ${tasks.map(task => task.migration.name).join('\n  ')}\n]\n`;
                }
                str += command;
            }
        }
        return str.trim();
    }
    execute(migrationDir, adapter, head, commit) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const task of this) {
                yield task.execute(migrationDir, adapter, head, commit);
            }
        });
    }
}
exports.TaskList = TaskList;
class Task {
    constructor(options) {
        this.id = options.id;
        this.type = options.type;
        this.migration = options.migration;
        this.commit = options.commit;
        this.head = options.head;
        this.appliedAt = options.appliedAt;
    }
    invert() {
        return new Task({
            id: this.id,
            type: this.type === 'up' ? 'down' : 'up',
            migration: this.migration,
            commit: this.commit,
            head: this.head,
            appliedAt: this.appliedAt,
        });
    }
    /**
     * Executes the task
     * @param migrationDir the fallback folder to search the migration in if no merkelrc can be found
     */
    execute(migrationDir, adapter, head, commit) {
        return __awaiter(this, void 0, void 0, function* () {
            yield adapter.checkIfTaskCanExecute(this);
            let migrationExports;
            if (commit) {
                const config = yield git_1.getConfigurationForCommit(commit);
                if (config && config.migrationOutDir) {
                    migrationDir = config.migrationOutDir;
                }
            }
            const path = yield this.migration.getPath(migrationDir);
            try {
                migrationExports = require(path);
            }
            catch (err) {
                throw new MigrationLoadError(this.migration, migrationDir, err);
            }
            if (typeof migrationExports[this.type] !== 'function') {
                throw new TaskTypeNotFoundError(this.migration, this.type, migrationDir);
            }
            try {
                let exceptionHandler;
                try {
                    yield Promise.race([
                        new Promise((_, reject) => {
                            exceptionHandler = reject;
                            process.on('uncaughtException', reject);
                        }),
                        Promise.resolve(migrationExports[this.type]()),
                    ]);
                }
                finally {
                    if (exceptionHandler) {
                        process.removeListener('uncaughtException', exceptionHandler);
                    }
                }
            }
            catch (err) {
                throw new MigrationExecutionError(err);
            }
            this.head = head;
            this.commit = commit;
            this.appliedAt = new Date();
            yield adapter.finishMigrationTask(this);
        });
    }
    /**
     * Converts the task to a short string including the type and migration name that can be shown
     * in the CLI
     */
    toString() {
        if (this.type === 'up') {
            return chalk_1.default.bgGreen('▲ UP   ' + this.migration.name);
        }
        else if (this.type === 'down') {
            return chalk_1.default.bgRed('▼ DOWN ' + this.migration.name);
        }
        else {
            throw new UnknownTaskTypeError(this.type);
        }
    }
}
exports.Task = Task;
//# sourceMappingURL=migration.js.map